<h1> 15686_치킨배달 </h1>

<br>
처음에 DFS로 치킨집 선택하고 BFS로 거리를 구했는데 메모리 초과가 떴다.<br>
사실 굳이 거리는 하나씩 따져가면서 풀면 되는데 왜 BFS를 써서 복잡하게 풀었을까<br>
<br> 
그래서 BFS 안쓰고 치킨집 좌표랑 가정집 좌표를 각각 다른 벡터에 담아놓고 하나씩 거리 비교하면서 각 치킨집과 가정집 사이의 거리 최솟값을 구하였다. <br> 
그랬더니 시간초과가 떴다. <br>

DFS 함수 파라미터로 index 값을 넘겨주어 시간초과가 발생하지 않을 줄 알았는데 아직도 왜 시간초과가 발생한지 잘 모르겠다.
<br>

    for(int i=idx;i<chicken.size();i++){
        visited[i]=1;
        DFS(cnt+1 , i+1);
        visited[i]=0;
    }
<br>
그래서 아래와 같이 DFS를 두번 호출하는걸로 바꿔줬더니 맞았다. <br>
저런 방법도 있다니 신기하다.<br>
    
    visited[idx] = 1;
    DFS(cnt+1,idx+1);
    visited[idx] = 0;
    DFS(cnt, idx+1);


다시 풀어보니까 위에 방법으로도 시간초과 없이 잘 나온다. <br>
그냥 아까 내가 idx 값을 틀린듯<br>
나는 첫번째 방법을 더 선호 <br><br>


<h1> 2018_카카오_블라인드_비밀지도 </h1>
<br>
처음에 이진수 구하는 방법으로 while에서 2로 계속 나눠주면서 구했는데 시간초과가 나왔다.<br>
풀이 봤더니 shift 연산으로 정말 간단하고 빠르게 구할 수 있는 문제였다 <br>
근데 어떻게 shift 연산자를 쓸 생각을 하지.. 다들 대단하다.<br><br>


<h1> 10026_적록색약 </h1>
<br>
BFS로 쉽게 풀 수 있는 문제


